1、JavaScript 的变量命名有两个限制：
变量名称必须仅包含字母，数字，符号 $ 和 _。
首字符必须非数字。
2、let — 现代的变量声明方式。
var — 老旧的变量声明方式。一般情况下，我们不会再使用它。但是，我们会在 旧时的 "var" 章节介绍 var 和 let 的微妙差别，以防你需要它们。
const — 类似于 let，但是变量的值无法被修改。
3、取余 %和求幂 **（求幂运算 a ** b 是 a 乘以自身 b 次。）
   运算元 —— 运算符应用的对象
   加号 + 被应用于字符串，它将合并（连接）各个字符串。注意:只要任意一个运算元是字符串，那么另一个运算元也将被转化为字符串
   二元 + 是唯一一个以这种方式支持字符串的运算符。其他算术运算符只对数字起作用，并且总是将其运算元转换为数字。例如：alert(2 + 2 + '1' ); // "41"，不是 "221"
   一元运算符加号，或者说，加号 + 应用于单个值，对数字没有任何作用。但是如果运算元不是数字，加号 + 则会将其转化为数字
   null 经过数字转换之后会变为 0。
   undefined 经过数字转换之后会变为 NaN
运算符优先级:
每个运算符都有对应的优先级数字。数字越大，越先执行。如果优先级相同，则按照由左至右的顺序执行。
17  一元加号	+
17	一元负号	-
16	求幂 	**
15	乘号	*
15	除号	/
13	加号	+
13	减号	-
…	…	…
3	赋值符
4、赋值 = 返回一个值（语句 x = value 将值 value 写入 x 然后返回 x）
5、原地修改：经常需要对一个变量做运算，并将新的结果存储在同一个变量中
let n = 2;
n += 5; // 现在 n = 7（等同于 n = n + 5）
n *= 2; // 现在 n = 14（等同于 n = n * 2）
alert( n ); // 14
6、+= 、*=、/= 和 -=这类运算符的优先级与普通赋值运算符的优先级相同，所以它们在大多数其他运算之后执行
7、自增 ++ 将变量与 1 相加
   自减 -- 将变量与 1 相减
   自增/自减只能应用于变量。试一下，将其应用于数值（比如 5++）则会报错，运算符 ++ 和 -- 可以置于变量前，也可以置于变量后
   （区别：所有的运算符都有返回值。自增/自减也不例外。前置形式返回一个新的值，但后置返回原来的值（做加法/减法之前的值））
   总结：1、如果自增/自减的值不会被使用，那么两者形式没有区别
         2、如果我们想要对变量进行自增操作，并且 需要立刻使用自增后的值，那么我们需要使用前置形式
         3、如果我们想要将一个数加一，但是我们想使用其自增之前的值，那么我们需要使用后置形式
8、逗号运算符能让我们处理多个语句，使用 , 将它们分开。每个语句都运行了，但是只有最后的语句的结果会被返回。注意：逗号运算符的优先级非常低，比 = 还要低
9、prompt 以字符串的形式返回用户的输入
10、值的比较
    1、所有比较运算符均返回布尔值
    2、比较的结果可以被赋值给任意变量
    3、字符串的比较算法非常简单：
首先比较两个字符串的首位字符大小。
如果一方字符较大（或较小），则该字符串大于（或小于）另一个字符串。算法结束。
否则，如果两个字符串的首位字符相等，则继续取出两个字符串各自的后一位字符进行比较。
重复上述步骤进行比较，直到比较完成某字符串的所有字符为止。
如果两个字符串的字符同时用完，那么则判定它们相等，否则未结束（还有未比较的字符）的字符串更大。
大写的 "A" 并不等于小写的 "a"
    4、当对不同类型的值进行比较时，JavaScript 会首先将其转化为数字（number）再判定大小
       对于布尔类型值，true 会被转化为 1、false 转化为 0
    5、普通的相等性检查 == 存在一个问题，它不能区分出 0 和 false，也同样无法区分空字符串和 false
       严格相等运算符 === 在进行比较时不会做任何的类型转换
       “严格不相等”表示为 !==
       当使用数学式或其他比较方法 < > <= >= 时，null/undefined 会被转化为数字：null 被转化为 0，undefined 被转化为 NaN
总结： 
比较运算符始终返回布尔值。
字符串的比较，会按照“词典”顺序逐字符地比较大小。
当对不同类型的值进行比较时，它们会先被转化为数字（不包括严格相等检查）再进行比较。
在非严格相等 == 下，null 和 undefined 相等且各自不等于任何其他的值。
在使用 > 或 < 进行比较时，需要注意变量可能为 null/undefined 的情况。比较好的方法是单独检查变量是否等于 null/undefined。
11、|| 返回第一个 真 值。?? 返回第一个 已定义的 值。
12、while —— 每次迭代之前都要检查条件。
    do..while —— 每次迭代后都要检查条件。
    for (;;) —— 每次迭代之前都要检查条件，可以使用其他设置
13、属性存在性测试，“in” 操作符（请注意，in 的左边必须是 属性名。通常是一个带引号的字符串）
14、变量名不能是编程语言的某个保留字，如 “for”、“let”、“return” 等……，但对象的属性名并不受此限制
15、当创建一个对象时，我们可以在对象字面量中使用方括号。这叫做 计算属性。
16、创建对象let user = new Object(); // “构造函数” 的语法，let user = {};  // “字面量” 的语法
    请注意：用 const 声明的对象 能 被修改。
17、点符号要求 key 是有效的变量标识符。这意味着：不包含空格，不以数字开头，也不包含特殊字符（允许使用 $ 和 _）。对于多词属性，使用方括号
18、为了遍历一个对象的所有键（key），可以使用一个特殊形式的循环：for..in。注意，所有的 “for” 结构体都允许我们在循环中定义变量，像这里的 let key。
    同样，我们可以用其他属性名来替代 key。例如 "for(let prop in obj)" 也很常用。
19、总结：对象是具有一些特殊特性的关联数组。
它们存储属性（键值对），其中：
属性的键必须是字符串或者 symbol（通常是字符串）。
值可以是任何类型。
我们可以用下面的方法访问属性：
点符号: obj.property。
方括号 obj["property"]，方括号允许从变量中获取键，例如 obj[varWithKey]。
其他操作：
删除属性：delete obj.prop。
检查是否存在给定键的属性："key" in obj。
遍历对象：for(let key in obj) 循环。
JavaScript 中还有很多其他类型的对象：
Array 用于存储有序数据集合，
Date 用于存储时间日期，
Error 用于存储错误信息。
20、对象拷贝
    变量存储的不是对象自身，而是该对象的“内存地址”，换句话说就是一个对该对象的“引用”
    当一个对象变量被拷贝 —— 引用则被拷贝，而该对象并没有被复制
    克隆与合并，Object.assign
对象通过引用被赋值和拷贝。换句话说，一个变量存储的不是“对象的值”，而是一个对值的“引用”（内存地址）。因此，拷贝此类变量或将其作为函数参数传递时，所拷贝的是引用，而不是对象本身。
所有通过被拷贝的引用的操作（如添加、删除属性）都作用在同一个对象上。
为了创建“真正的拷贝”（一个克隆），我们可以使用 Object.assign 来做所谓的“浅拷贝”（嵌套对象被通过引用进行拷贝）或者使用“深拷贝”函数，例如 _.cloneDeep(obj)。
















    
    
    
    
    
    
    
   
